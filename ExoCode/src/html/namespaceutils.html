<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TeensyNanoExoCode: utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TeensyNanoExoCode
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>contains general utility functions for the exo  
<a href="namespaceutils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionutils_1_1_float_byte_union.html">FloatByteUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionutils_1_1_short_int_byte_union.html">ShortIntByteUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutils_1_1_speed_check.html">SpeedCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to check the loop speed without serial prints, by toggling a pin after initialized, toggle will need to be called each loop.  <a href="classutils_1_1_speed_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac45099964358cacf2a7628c3300c699d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ac45099964358cacf2a7628c3300c699d">get_is_left</a> (<a class="el" href="namespaceconfig__defs.html#a2d58dbc79a5104d434847439a5d6f076">config_defs::joint_id</a> id)</td></tr>
<tr class="memdesc:ac45099964358cacf2a7628c3300c699d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in the joint id and returns if the left indicator bit is set as a bool.  <br /></td></tr>
<tr class="separator:ac45099964358cacf2a7628c3300c699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807b0fc90f9c749643f9bd06e7ce2e26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a807b0fc90f9c749643f9bd06e7ce2e26">get_is_left</a> (uint8_t id)</td></tr>
<tr class="memdesc:a807b0fc90f9c749643f9bd06e7ce2e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in the joint id and returns if the left indicator bit is set as a bool.  <br /></td></tr>
<tr class="separator:a807b0fc90f9c749643f9bd06e7ce2e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55778f7db8215731d334c8babb1aaf5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aa55778f7db8215731d334c8babb1aaf5">get_joint_type</a> (<a class="el" href="namespaceconfig__defs.html#a2d58dbc79a5104d434847439a5d6f076">config_defs::joint_id</a> id)</td></tr>
<tr class="memdesc:aa55778f7db8215731d334c8babb1aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in the joint id and returns the id with the left/right bits masked out. Returning uint8_t rather than joint_id type since we have to typecast to do logical stuff anyways.  <br /></td></tr>
<tr class="separator:aa55778f7db8215731d334c8babb1aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4420cc52e1886d8e600273c0fe577f6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ae4420cc52e1886d8e600273c0fe577f6">get_joint_type</a> (uint8_t id)</td></tr>
<tr class="memdesc:ae4420cc52e1886d8e600273c0fe577f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in the joint id and returns the id with the left/right bits masked out. Returning uint8_t rather than joint_id type since we have to typecast to do logical stuff anyways.  <br /></td></tr>
<tr class="separator:ae4420cc52e1886d8e600273c0fe577f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0aa3b6a3f8c6b4beb4ac3b19d644c10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ad0aa3b6a3f8c6b4beb4ac3b19d644c10">schmitt_trigger</a> (float value, bool is_high, float lower_threshold, float upper_threshold)</td></tr>
<tr class="memdesc:ad0aa3b6a3f8c6b4beb4ac3b19d644c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the new state of the system based on the value and past state. Takes in the current value, if the state is currently high, and the lower and upper threshold Floats are used so that ints will be promoted but it will still work with floats. May cause issues with very large ints. Templates could be used in the future but seemed to have issues if all types were not present in the template, e.g. is_high is always a bool. A schmitt trigger is a way of tracking if a noisy signal is high or low When it is low it must go above the upper threshold before it is high When it is high it must go below the lower threshold before it is low. This way if the signal crosses one threshold multiple times it won't register as changing multiple times.  <br /></td></tr>
<tr class="separator:ad0aa3b6a3f8c6b4beb4ac3b19d644c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6323a0e1b1bea3fc70fbda077efb1475"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a6323a0e1b1bea3fc70fbda077efb1475">rate_limit</a> (int setpoint, int last_value, int *last_time, int rate_per_ms)</td></tr>
<tr class="memdesc:a6323a0e1b1bea3fc70fbda077efb1475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits the rate at which a value can change. <br  />
 This is useful when you would like a variable to gradually come on.  <br /></td></tr>
<tr class="separator:a6323a0e1b1bea3fc70fbda077efb1475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ce03bb77c282406857c9d80838007"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a626ce03bb77c282406857c9d80838007">update_bit</a> (uint8_t original, bool val, uint8_t loc)</td></tr>
<tr class="memdesc:a626ce03bb77c282406857c9d80838007"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets/clears the specified bit in a unit8_t.  <br /></td></tr>
<tr class="separator:a626ce03bb77c282406857c9d80838007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61a9190ab9a27c5b59305a70b7ae65"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aeb61a9190ab9a27c5b59305a70b7ae65">update_bit</a> (uint16_t original, bool val, uint8_t loc)</td></tr>
<tr class="memdesc:aeb61a9190ab9a27c5b59305a70b7ae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets/clears the specified bit in a unit16_t.  <br /></td></tr>
<tr class="separator:aeb61a9190ab9a27c5b59305a70b7ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fd086c9652b1287b6cbf9c6e12c54b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a11fd086c9652b1287b6cbf9c6e12c54b">get_bit</a> (uint8_t original, uint8_t loc)</td></tr>
<tr class="memdesc:a11fd086c9652b1287b6cbf9c6e12c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit in a specific location in a uint8_t.  <br /></td></tr>
<tr class="separator:a11fd086c9652b1287b6cbf9c6e12c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701a62b97b071eef0df46591a4703b86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a701a62b97b071eef0df46591a4703b86">get_bit</a> (uint16_t original, uint8_t loc)</td></tr>
<tr class="memdesc:a701a62b97b071eef0df46591a4703b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit in a specific location in a uint16.  <br /></td></tr>
<tr class="separator:a701a62b97b071eef0df46591a4703b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ef823108dc95f6ff5e732b61002eaa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a93ef823108dc95f6ff5e732b61002eaa">degrees_to_radians</a> (float)</td></tr>
<tr class="memdesc:a93ef823108dc95f6ff5e732b61002eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from degrees to radians  <br /></td></tr>
<tr class="separator:a93ef823108dc95f6ff5e732b61002eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc9902175a83a7299385cf9deaf48ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a0bc9902175a83a7299385cf9deaf48ff">radians_to_degrees</a> (float)</td></tr>
<tr class="memdesc:a0bc9902175a83a7299385cf9deaf48ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from radians to degrees  <br /></td></tr>
<tr class="separator:a0bc9902175a83a7299385cf9deaf48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba66776ed296852181b0a1c371f3e0cf"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aba66776ed296852181b0a1c371f3e0cf">remove_all_chars</a> (String str, char rmv)</td></tr>
<tr class="memdesc:aba66776ed296852181b0a1c371f3e0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches str for 'rmv characters and deletes them all, returns new string todo: Chance update comments.  <br /></td></tr>
<tr class="separator:aba66776ed296852181b0a1c371f3e0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1f31bd1a52fe89fba2107152360b76"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aab1f31bd1a52fe89fba2107152360b76">remove_all_chars</a> (char *arr, char rmv)</td></tr>
<tr class="separator:aab1f31bd1a52fe89fba2107152360b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7436ae25cb24b70aa9cb6c24a75e5a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aa7436ae25cb24b70aa9cb6c24a75e5a0">get_char_length</a> (int ofInt)</td></tr>
<tr class="memdesc:aa7436ae25cb24b70aa9cb6c24a75e5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">given and integer, return the number of characters in it todo: Chance update comments  <br /></td></tr>
<tr class="separator:aa7436ae25cb24b70aa9cb6c24a75e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccbd7cf1148da7ed6c9ffa99000aa1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aaccbd7cf1148da7ed6c9ffa99000aa1a">is_little_endian</a> ()</td></tr>
<tr class="memdesc:aaccbd7cf1148da7ed6c9ffa99000aa1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if system uses little endian floating points. This confirms that the floating points match if not the byte order needs to be flipped. Not tested with big endian or 64 bit systems.  <br /></td></tr>
<tr class="separator:aaccbd7cf1148da7ed6c9ffa99000aa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae506b587b15eea4c765e622ba9b23c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ae506b587b15eea4c765e622ba9b23c5a">float_to_uint8</a> (float num_to_convert, uint8_t *converted_bytes)</td></tr>
<tr class="memdesc:ae506b587b15eea4c765e622ba9b23c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in a float and a byte array reference Puts the bytes of the float into the array in little endian Not tested with big endian or 64 bit systems.  <br /></td></tr>
<tr class="separator:ae506b587b15eea4c765e622ba9b23c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac266187e7c33bab738ee595062da2088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ac266187e7c33bab738ee595062da2088">uint8_to_float</a> (uint8_t *bytes_to_convert, float *converted_float)</td></tr>
<tr class="memdesc:ac266187e7c33bab738ee595062da2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in a byte array address in little endian form containing a broken up float Returns a reconstituted float from the bytes in the form (endianess) the system uses. Not tested with big endian or 64 bit systems.  <br /></td></tr>
<tr class="separator:ac266187e7c33bab738ee595062da2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab57a56061fc3e9756fb852e2a9f5ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aab57a56061fc3e9756fb852e2a9f5ca7">float_to_short_fixed_point_bytes</a> (float num_to_convert, uint8_t *converted_bytes, uint8_t factor)</td></tr>
<tr class="memdesc:aab57a56061fc3e9756fb852e2a9f5ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts float into individual bytes of a fixed point short. <br  />
  <br /></td></tr>
<tr class="separator:aab57a56061fc3e9756fb852e2a9f5ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f75cc84116926faf99abaf0abce7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af80f75cc84116926faf99abaf0abce7b">short_fixed_point_bytes_to_float</a> (uint8_t *bytes_to_convert, float *converted_val, uint8_t factor)</td></tr>
<tr class="memdesc:af80f75cc84116926faf99abaf0abce7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a set of bytes in a fixed point short int into a float  <br /></td></tr>
<tr class="separator:af80f75cc84116926faf99abaf0abce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29b08cdde8e83e33543eb80cd0960d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#abf29b08cdde8e83e33543eb80cd0960d">ewma</a> (float new_value, float filter_value, float alpha)</td></tr>
<tr class="memdesc:abf29b08cdde8e83e33543eb80cd0960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential Weighted Moving Average. Used to smooth out noisy data.  <br /></td></tr>
<tr class="separator:abf29b08cdde8e83e33543eb80cd0960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d245e124572d40cc1500e2aa97f3b49"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a8d245e124572d40cc1500e2aa97f3b49">ff_to_fe</a> (uint8_t val)</td></tr>
<tr class="separator:a8d245e124572d40cc1500e2aa97f3b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a4ec118f6bac1ee36f29a27013c528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ab4a4ec118f6bac1ee36f29a27013c528">spin_on_error_with</a> (String message)</td></tr>
<tr class="memdesc:ab4a4ec118f6bac1ee36f29a27013c528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Never returns from this function, used for critical errors.  <br /></td></tr>
<tr class="separator:ab4a4ec118f6bac1ee36f29a27013c528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e4bd58ef05f006f93682bda9b98c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a41e4bd58ef05f006f93682bda9b98c42">is_close_to</a> (float val1, float val2, float tolerance)</td></tr>
<tr class="memdesc:a41e4bd58ef05f006f93682bda9b98c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two floats are close to each other within a tolerance.  <br /></td></tr>
<tr class="separator:a41e4bd58ef05f006f93682bda9b98c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0613d9e40ec11d3e17655132b61ad2a0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a0613d9e40ec11d3e17655132b61ad2a0">online_std_dev</a> (std::queue&lt; float &gt; set)</td></tr>
<tr class="memdesc:a0613d9e40ec11d3e17655132b61ad2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of data and maximum size. Returns the new mean and standard deviation.  <br /></td></tr>
<tr class="separator:a0613d9e40ec11d3e17655132b61ad2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af362fe7671d3080b044a58b906c66c39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af362fe7671d3080b044a58b906c66c39">is_outside_range</a> (float val, float min, float max)</td></tr>
<tr class="memdesc:af362fe7671d3080b044a58b906c66c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a value is outside of a range.  <br /></td></tr>
<tr class="separator:af362fe7671d3080b044a58b906c66c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e34137dce08af5264701cd26ce671"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a710e34137dce08af5264701cd26ce671">remove_all_chars</a> (char *arr, int len, char rmv)</td></tr>
<tr class="separator:a710e34137dce08af5264701cd26ce671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8908e882fc6b3ba22e6b2cc9b79d9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d8908e882fc6b3ba22e6b2cc9b79d9c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a2d8908e882fc6b3ba22e6b2cc9b79d9c">elements_are_equal</a> (T arr1, T arr2, int length)</td></tr>
<tr class="memdesc:a2d8908e882fc6b3ba22e6b2cc9b79d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements of the array are equal. Arrays must be the same length and type todo: Chance update comments.  <br /></td></tr>
<tr class="separator:a2d8908e882fc6b3ba22e6b2cc9b79d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ed0c3f170a66d963071975405aa71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca9ed0c3f170a66d963071975405aa71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aca9ed0c3f170a66d963071975405aa71">set_elements_equal</a> (T arr1, T arr2, int length)</td></tr>
<tr class="memdesc:aca9ed0c3f170a66d963071975405aa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arr2 elements equal to arr1 elements. Arrays must be the same length and type todo: Chance update comments.  <br /></td></tr>
<tr class="separator:aca9ed0c3f170a66d963071975405aa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>contains general utility functions for the exo </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a93ef823108dc95f6ff5e732b61002eaa" name="a93ef823108dc95f6ff5e732b61002eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ef823108dc95f6ff5e732b61002eaa">&#9670;&#160;</a></span>degrees_to_radians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float utils::degrees_to_radians </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts from degrees to radians </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>degree value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value converted to radians </dd></dl>

</div>
</div>
<a id="a2d8908e882fc6b3ba22e6b2cc9b79d9c" name="a2d8908e882fc6b3ba22e6b2cc9b79d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8908e882fc6b3ba22e6b2cc9b79d9c">&#9670;&#160;</a></span>elements_are_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utils::elements_are_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all elements of the array are equal. Arrays must be the same length and type todo: Chance update comments. </p>

</div>
</div>
<a id="abf29b08cdde8e83e33543eb80cd0960d" name="abf29b08cdde8e83e33543eb80cd0960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf29b08cdde8e83e33543eb80cd0960d">&#9670;&#160;</a></span>ewma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float utils::ewma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filter_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential Weighted Moving Average. Used to smooth out noisy data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_value</td><td>New value to add to the filter </td></tr>
    <tr><td class="paramname">filter_value</td><td>Previous value of the filter </td></tr>
    <tr><td class="paramname">alpha</td><td>Tuning parameter, 0.0 &lt; alpha &lt; 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

</div>
</div>
<a id="a8d245e124572d40cc1500e2aa97f3b49" name="a8d245e124572d40cc1500e2aa97f3b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d245e124572d40cc1500e2aa97f3b49">&#9670;&#160;</a></span>ff_to_fe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::ff_to_fe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab57a56061fc3e9756fb852e2a9f5ca7" name="aab57a56061fc3e9756fb852e2a9f5ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab57a56061fc3e9756fb852e2a9f5ca7">&#9670;&#160;</a></span>float_to_short_fixed_point_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utils::float_to_short_fixed_point_bytes </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>num_to_convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>converted_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts float into individual bytes of a fixed point short. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>to convert </td></tr>
    <tr><td class="paramname">array</td><td>of sizeof(short int) to store the individual bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae506b587b15eea4c765e622ba9b23c5a" name="ae506b587b15eea4c765e622ba9b23c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae506b587b15eea4c765e622ba9b23c5a">&#9670;&#160;</a></span>float_to_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utils::float_to_uint8 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>num_to_convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>converted_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in a float and a byte array reference Puts the bytes of the float into the array in little endian Not tested with big endian or 64 bit systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>to convert </td></tr>
    <tr><td class="paramname">array</td><td>of sizeof(float) to store the individual bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701a62b97b071eef0df46591a4703b86" name="a701a62b97b071eef0df46591a4703b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701a62b97b071eef0df46591a4703b86">&#9670;&#160;</a></span>get_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::get_bit </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bit in a specific location in a uint16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>uint16_t to read </td></tr>
    <tr><td class="paramname">the</td><td>location of the bit to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the bit location </dd></dl>

</div>
</div>
<a id="a11fd086c9652b1287b6cbf9c6e12c54b" name="a11fd086c9652b1287b6cbf9c6e12c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fd086c9652b1287b6cbf9c6e12c54b">&#9670;&#160;</a></span>get_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::get_bit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bit in a specific location in a uint8_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>uint8_t to read </td></tr>
    <tr><td class="paramname">the</td><td>location of the bit to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the bit location </dd></dl>

</div>
</div>
<a id="aa7436ae25cb24b70aa9cb6c24a75e5a0" name="aa7436ae25cb24b70aa9cb6c24a75e5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7436ae25cb24b70aa9cb6c24a75e5a0">&#9670;&#160;</a></span>get_char_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int utils::get_char_length </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ofInt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given and integer, return the number of characters in it todo: Chance update comments </p>

</div>
</div>
<a id="ac45099964358cacf2a7628c3300c699d" name="ac45099964358cacf2a7628c3300c699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45099964358cacf2a7628c3300c699d">&#9670;&#160;</a></span>get_is_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::get_is_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceconfig__defs.html#a2d58dbc79a5104d434847439a5d6f076">config_defs::joint_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in the joint id and returns if the left indicator bit is set as a bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the id is for the left side </dd></dl>

</div>
</div>
<a id="a807b0fc90f9c749643f9bd06e7ce2e26" name="a807b0fc90f9c749643f9bd06e7ce2e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807b0fc90f9c749643f9bd06e7ce2e26">&#9670;&#160;</a></span>get_is_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::get_is_left </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in the joint id and returns if the left indicator bit is set as a bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the id is for the left side </dd></dl>

</div>
</div>
<a id="aa55778f7db8215731d334c8babb1aaf5" name="aa55778f7db8215731d334c8babb1aaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55778f7db8215731d334c8babb1aaf5">&#9670;&#160;</a></span>get_joint_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::get_joint_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceconfig__defs.html#a2d58dbc79a5104d434847439a5d6f076">config_defs::joint_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in the joint id and returns the id with the left/right bits masked out. Returning uint8_t rather than joint_id type since we have to typecast to do logical stuff anyways. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joint id with the side bits masked out </dd></dl>

</div>
</div>
<a id="ae4420cc52e1886d8e600273c0fe577f6" name="ae4420cc52e1886d8e600273c0fe577f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4420cc52e1886d8e600273c0fe577f6">&#9670;&#160;</a></span>get_joint_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::get_joint_type </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in the joint id and returns the id with the left/right bits masked out. Returning uint8_t rather than joint_id type since we have to typecast to do logical stuff anyways. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joint id with the side bits masked out </dd></dl>

</div>
</div>
<a id="a41e4bd58ef05f006f93682bda9b98c42" name="a41e4bd58ef05f006f93682bda9b98c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e4bd58ef05f006f93682bda9b98c42">&#9670;&#160;</a></span>is_close_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::is_close_to </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two floats are close to each other within a tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td></td></tr>
    <tr><td class="paramname">val2</td><td></td></tr>
    <tr><td class="paramname">tolerance</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="aaccbd7cf1148da7ed6c9ffa99000aa1a" name="aaccbd7cf1148da7ed6c9ffa99000aa1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccbd7cf1148da7ed6c9ffa99000aa1a">&#9670;&#160;</a></span>is_little_endian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::is_little_endian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if system uses little endian floating points. This confirms that the floating points match if not the byte order needs to be flipped. Not tested with big endian or 64 bit systems. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if system is little endian </dd></dl>

</div>
</div>
<a id="af362fe7671d3080b044a58b906c66c39" name="af362fe7671d3080b044a58b906c66c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af362fe7671d3080b044a58b906c66c39">&#9670;&#160;</a></span>is_outside_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::is_outside_range </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a value is outside of a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
    <tr><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramname">max</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a0613d9e40ec11d3e17655132b61ad2a0" name="a0613d9e40ec11d3e17655132b61ad2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0613d9e40ec11d3e17655132b61ad2a0">&#9670;&#160;</a></span>online_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; float, float &gt; utils::online_std_dev </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; float &gt;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of data and maximum size. Returns the new mean and standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>Queue of data to calculate the mean and standard deviation of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;float, float&gt; Mean and standard deviation, respectively </dd></dl>

</div>
</div>
<a id="a0bc9902175a83a7299385cf9deaf48ff" name="a0bc9902175a83a7299385cf9deaf48ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc9902175a83a7299385cf9deaf48ff">&#9670;&#160;</a></span>radians_to_degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float utils::radians_to_degrees </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts from radians to degrees </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>radian value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value converted to degrees </dd></dl>

</div>
</div>
<a id="a6323a0e1b1bea3fc70fbda077efb1475" name="a6323a0e1b1bea3fc70fbda077efb1475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6323a0e1b1bea3fc70fbda077efb1475">&#9670;&#160;</a></span>rate_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int utils::rate_limit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>last_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate_per_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limits the rate at which a value can change. <br  />
 This is useful when you would like a variable to gradually come on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>value the system is moving towards </td></tr>
    <tr><td class="paramname">the</td><td>previous value the system was at </td></tr>
    <tr><td class="paramname">pointer</td><td>to the last time the output value was set </td></tr>
    <tr><td class="paramname">rate</td><td>the value can change per ms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next value to the system can be at based on the rate limit. </dd></dl>

</div>
</div>
<a id="aab1f31bd1a52fe89fba2107152360b76" name="aab1f31bd1a52fe89fba2107152360b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1f31bd1a52fe89fba2107152360b76">&#9670;&#160;</a></span>remove_all_chars() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String utils::remove_all_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rmv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a710e34137dce08af5264701cd26ce671" name="a710e34137dce08af5264701cd26ce671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710e34137dce08af5264701cd26ce671">&#9670;&#160;</a></span>remove_all_chars() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String utils::remove_all_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rmv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba66776ed296852181b0a1c371f3e0cf" name="aba66776ed296852181b0a1c371f3e0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba66776ed296852181b0a1c371f3e0cf">&#9670;&#160;</a></span>remove_all_chars() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String utils::remove_all_chars </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rmv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches str for 'rmv characters and deletes them all, returns new string todo: Chance update comments. </p>

</div>
</div>
<a id="ad0aa3b6a3f8c6b4beb4ac3b19d644c10" name="ad0aa3b6a3f8c6b4beb4ac3b19d644c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0aa3b6a3f8c6b4beb4ac3b19d644c10">&#9670;&#160;</a></span>schmitt_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utils::schmitt_trigger </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lower_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upper_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the new state of the system based on the value and past state. Takes in the current value, if the state is currently high, and the lower and upper threshold Floats are used so that ints will be promoted but it will still work with floats. May cause issues with very large ints. Templates could be used in the future but seemed to have issues if all types were not present in the template, e.g. is_high is always a bool. A schmitt trigger is a way of tracking if a noisy signal is high or low When it is low it must go above the upper threshold before it is high When it is high it must go below the lower threshold before it is low. This way if the signal crosses one threshold multiple times it won't register as changing multiple times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>current signal reading </td></tr>
    <tr><td class="paramname">The</td><td>current state of the trigger </td></tr>
    <tr><td class="paramname">The</td><td>lower threshold a high signal must pass to go low </td></tr>
    <tr><td class="paramname">The</td><td>upper threshold a low signal must pass to go high</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of the trigger. </dd></dl>

</div>
</div>
<a id="aca9ed0c3f170a66d963071975405aa71" name="aca9ed0c3f170a66d963071975405aa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9ed0c3f170a66d963071975405aa71">&#9670;&#160;</a></span>set_elements_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utils::set_elements_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets arr2 elements equal to arr1 elements. Arrays must be the same length and type todo: Chance update comments. </p>

</div>
</div>
<a id="af80f75cc84116926faf99abaf0abce7b" name="af80f75cc84116926faf99abaf0abce7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80f75cc84116926faf99abaf0abce7b">&#9670;&#160;</a></span>short_fixed_point_bytes_to_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utils::short_fixed_point_bytes_to_float </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes_to_convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>converted_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a set of bytes in a fixed point short int into a float </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>of size sizeof(short int) containing the bytes to convert </td></tr>
    <tr><td class="paramname">pointer</td><td>to place the converted value into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4a4ec118f6bac1ee36f29a27013c528" name="ab4a4ec118f6bac1ee36f29a27013c528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a4ec118f6bac1ee36f29a27013c528">&#9670;&#160;</a></span>spin_on_error_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utils::spin_on_error_with </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Never returns from this function, used for critical errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac266187e7c33bab738ee595062da2088" name="ac266187e7c33bab738ee595062da2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac266187e7c33bab738ee595062da2088">&#9670;&#160;</a></span>uint8_to_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utils::uint8_to_float </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes_to_convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>converted_float</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes in a byte array address in little endian form containing a broken up float Returns a reconstituted float from the bytes in the form (endianess) the system uses. Not tested with big endian or 64 bit systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>of size sizeof(float) containing the bytes to convert </td></tr>
    <tr><td class="paramname">pointer</td><td>to place the converted value into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb61a9190ab9a27c5b59305a70b7ae65" name="aeb61a9190ab9a27c5b59305a70b7ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb61a9190ab9a27c5b59305a70b7ae65">&#9670;&#160;</a></span>update_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t utils::update_bit </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets/clears the specified bit in a unit16_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>original uint16_t </td></tr>
    <tr><td class="paramname">The</td><td>bit value you would like to use </td></tr>
    <tr><td class="paramname">The</td><td>location you are placing that bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uint16_t with the bit updated </dd></dl>

</div>
</div>
<a id="a626ce03bb77c282406857c9d80838007" name="a626ce03bb77c282406857c9d80838007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626ce03bb77c282406857c9d80838007">&#9670;&#160;</a></span>update_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::update_bit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets/clears the specified bit in a unit8_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>original uint8_t </td></tr>
    <tr><td class="paramname">The</td><td>bit value you would like to use </td></tr>
    <tr><td class="paramname">The</td><td>location you are placing that bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uint8_t with the bit updated </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
